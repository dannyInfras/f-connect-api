name: Deploy to DigitalOcean (Docker Compose)

on:
  push:
    branches:
      - develop
  workflow_dispatch:
    inputs:
      force_deploy:
        description: "Force deployment even if no changes detected"
        required: false
        default: false
        type: boolean

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  deploy:
    name: ðŸ³ Deploy with Docker Compose
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Cache Docker layers
        uses: actions/cache@v3
        with:
          path: /tmp/docker-cache
          key: ${{ runner.os }}-docker-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-docker-

      - name: Setup SSH agent
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.DO_SSH_PRIVATE_KEY }}

      - name: Add droplet to known_hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.DO_DEPLOY_HOST }} >> ~/.ssh/known_hosts
          chmod 600 ~/.ssh/known_hosts

      - name: Sync project
        run: |
          rsync -avz --delete \
            --rsync-path="sudo rsync" \
            --exclude='.git' \
            --exclude='node_modules' \
            --exclude='logs' \
            --exclude='dist' \
            --exclude='.github' \
            ./ \
            ${{ secrets.DO_DEPLOY_USER }}@${{ secrets.DO_DEPLOY_HOST }}:${{ secrets.DEPLOY_PATH }}

      - name: Deploy development environment
        id: deploy
        run: |
          ssh -o BatchMode=yes -o StrictHostKeyChecking=no \
            ${{ secrets.DO_DEPLOY_USER }}@${{ secrets.DO_DEPLOY_HOST }} << 'EOF'
            set -e

            sudo cp -r ${{ secrets.SECRET_PATH }}/.env ${{ secrets.DEPLOY_PATH }}/.env

            sudo chown ${{ secrets.DO_DEPLOY_USER }}:${{ secrets.DO_DEPLOY_USER }} ${{ secrets.DEPLOY_PATH }}/.env
            
            sudo chmod 600 ${{ secrets.DEPLOY_PATH }}/.env

            cd ${{ secrets.DEPLOY_PATH }}

            docker compose config > /dev/null
            docker compose down app || true
            docker image prune -f
            docker compose up -d --build --no-deps app
            docker image prune -f
          EOF

      - name: Healthcheck
        id: healthcheck
        run: |
          echo "ðŸ” Healthcheck started"
          max_retries=12
          retry_interval=10
          for i in $(seq 1 $max_retries); do
            echo "Attempt $i of $max_retries..."
            if curl -sSf --max-time 5 http://${{ secrets.DO_DEPLOY_HOST }}:${{ secrets.DO_DEPLOY_PORT }}/${{ secrets.HEALTHCHECK_PATH }}; then
              echo "âœ… App is healthy."
              echo "status=success" >> $GITHUB_OUTPUT
              exit 0
            fi
            echo "Waiting for appâ€¦ ($i/$max_retries)"
            sleep $retry_interval
          done
          echo "âŒ Healthcheck failed after $max_retries attempts."
          echo "status=failed" >> $GITHUB_OUTPUT

          echo "Collecting container logs for troubleshooting..."
          ssh -o BatchMode=yes ${{ secrets.DO_DEPLOY_USER }}@${{ secrets.DO_DEPLOY_HOST }} \
            "cd ${{ secrets.DEPLOY_PATH }} && docker compose logs --tail=100 app" > deployment-logs.txt

          cat deployment-logs.txt
          exit 1

      - name: Rollback on failure
        if: failure() && steps.deploy.outcome == 'success'
        run: |
          echo "ðŸ”„ Deployment failed, attempting rollback..."
          ssh -o BatchMode=yes -o StrictHostKeyChecking=no \
            ${{ secrets.DO_DEPLOY_USER }}@${{ secrets.DO_DEPLOY_HOST }} << 'EOF'
            cd ${{ secrets.DEPLOY_PATH }}
            docker compose down app
            docker compose up -d app
          EOF

  notify:
    name: ðŸ“¢ Send notifications
    runs-on: ubuntu-latest
    needs: deploy
    if: always()
    steps:
      - name: Set status
        id: status
        run: |
          if [[ "${{ needs.deploy.result }}" == "success" ]]; then
            echo "result=success" >> $GITHUB_OUTPUT
            echo "message=Deployment completed successfully" >> $GITHUB_OUTPUT
          else
            echo "result=failed" >> $GITHUB_OUTPUT
            echo "message=Deployment failed, see logs for details" >> $GITHUB_OUTPUT
          fi

      - name: Send deployment report to Slack
        uses: slackapi/slack-github-action@v1.24.0
        with:
          payload: |
            {
              "text": "Deployment Report",
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "Deployment Report"
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*Status:* ${{ steps.status.outputs.result == 'success' && ':white_check_mark: Success' || ':x: Failed' }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Details:* ${{ steps.status.outputs.message }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Branch:* ${{ github.ref_name }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Commit:* ${{ github.event.head_commit.message }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Triggered by:* ${{ github.actor }}"
                    }
                  ]
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Workflow Run>*"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK
